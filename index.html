<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>È´òÂ±±ÊóèÈü≥ÂæãËûçÂêàÂô®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'PingFang TC', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .title {
            font-size: 2.5em;
            color: #ffffff;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .tribal-pattern {
            height: 4px;
            background: linear-gradient(90deg, rgba(255,255,255,0.3), rgba(255,255,255,0.8), rgba(255,255,255,0.3));
            margin: 20px auto;
            border-radius: 2px;
            max-width: 600px;
        }

        .track-control-section {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            margin: 30px auto;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .track-control-title {
            color: white;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .track-count-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .track-count-btn {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.95em;
        }

        .track-count-btn.active {
            background: rgba(255, 255, 255, 0.7);
            color: #764ba2;
            font-weight: bold;
        }

        .track-count-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .track-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .track-title {
            color: white;
            font-size: 1.3em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .track-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-label {
            display: inline-block;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
        }

        .file-label:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .record-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
        }

        .record-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .record-btn.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        .track-play-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
        }

        .track-play-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .track-play-btn.playing {
            background: #43e97b;
        }

        .track-download-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
        }

        .track-download-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.5);
        }

        .track-download-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .delay-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .delay-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95em;
            min-width: 80px;
        }

        .delay-input {
            flex: 1;
            max-width: 300px;
        }

        .delay-value {
            color: white;
            font-weight: bold;
            min-width: 80px;
            text-align: right;
            font-size: 0.95em;
        }

        .waveform-container {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            cursor: grab;
            margin-top: 10px;
            height: 120px;
        }

        .waveform-container:active {
            cursor: grabbing;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .playback-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            display: none;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 18px 40px;
            font-size: 1.1em;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            color: white;
        }

        .play-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .pause-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stop-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .time-display {
            text-align: center;
            margin: 20px 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        .status {
            text-align: center;
            color: #ffffff;
            font-size: 1.2em;
            margin-top: 30px;
            min-height: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .track-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
            margin-top: 10px;
            text-align: center;
        }

        @media (max-width: 768px) {
            body {
                padding: 20px 10px;
            }

            .title {
                font-size: 1.8em;
            }

            .track-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .track-controls {
                width: 100%;
                justify-content: center;
            }

            .delay-control {
                flex-direction: column;
                align-items: stretch;
            }

            .delay-value {
                text-align: center;
            }

            .control-btn {
                width: 100%;
                max-width: 300px;
            }

            .waveform-container {
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">üéµ È´òÂ±±ÊóèÈü≥ÂæãËûçÂêàÂô®</h1>
            <p class="subtitle">Á≤æÂáÜÂØπÈΩê ¬∑ ÂÆåÁæéËûçÂêà</p>
            <div class="tribal-pattern"></div>
        </div>

        <div class="track-control-section">
            <div class="track-control-title">üéõÔ∏è ÈÄâÊã©Èü≥ËΩ®Êï∞Èáè</div>
            <div class="track-count-selector">
                <button class="track-count-btn active" data-count="1">1 ‰∏™Èü≥ËΩ®</button>
                <button class="track-count-btn" data-count="2">2 ‰∏™Èü≥ËΩ®</button>
                <button class="track-count-btn" data-count="3">3 ‰∏™Èü≥ËΩ®</button>
            </div>
        </div>

        <div id="tracksContainer"></div>

        <div class="time-display">
            <span id="currentTime">00:00</span> / <span id="duration">00:00</span>
        </div>

        <div class="controls">
            <button class="control-btn play-btn" id="playBtn">‚ñ∂ Êí≠ÊîæÂÖ®ÈÉ®</button>
            <button class="control-btn pause-btn" id="pauseBtn">‚è∏ ÊöÇÂÅúÂÖ®ÈÉ®</button>
            <button class="control-btn stop-btn" id="stopBtn">‚èπ ÂÅúÊ≠¢ÂÖ®ÈÉ®</button>
            <button class="control-btn stop-btn" id="downloadMergedBtn" disabled>‚¨áÔ∏è ‰∏ãËΩΩËûçÂêàÈü≥È¢ë</button>
        </div>

        <div class="status" id="status">ËØ∑Âä†ËΩΩÈü≥È¢ëÊñá‰ª∂ÊàñÂΩïÂà∂Èü≥È¢ë</div>
    </div>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffers = [null, null, null];
        let audioSources = [null, null, null];
        let delays = [0, 0, 0];
        let startTime = 0;
        let pauseTime = 0;
        let isPlaying = false;
        let animationId = null;
        let mediaRecorders = [null, null, null];
        let recordingChunks = [[], [], []];
        let waveformCanvases = [];
        let playbackLines = [];
        let isDragging = [false, false, false];
        let dragStartX = [0, 0, 0];
        let dragStartDelay = [0, 0, 0];
        let trackCount = 1;
        
        let trackSources = [null, null, null];
        let isTrackPlaying = [false, false, false];
        let trackAnimationIds = [null, null, null];
        let trackStartTimes = [0, 0, 0];
        let trackPauseTimes = [0, 0, 0];

        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const downloadMergedBtn = document.getElementById('downloadMergedBtn');
        const status = document.getElementById('status');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const tracksContainer = document.getElementById('tracksContainer');

        createTracks(trackCount);

        document.querySelectorAll('.track-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.track-count-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                trackCount = parseInt(btn.dataset.count);
                createTracks(trackCount);
            });
        });

        function createTracks(count) {
            stopBtn.click();
            
            tracksContainer.innerHTML = '';
            audioBuffers = [null, null, null];
            delays = [0, 0, 0];
            waveformCanvases = [];
            playbackLines = [];
            
            for (let i = 1; i <= count; i++) {
                createTrack(i);
            }
            
            updateStatus();
        }

        function createTrack(trackNum) {
            const index = trackNum - 1;
            const colors = ['#f093fb', '#4facfe', '#43e97b'];
            
            const trackDiv = document.createElement('div');
            trackDiv.className = 'track-container';
            trackDiv.id = `track${trackNum}`;
            trackDiv.style.background = `linear-gradient(135deg, ${colors[index]}22, ${colors[index]}11)`;
            
            trackDiv.innerHTML = `
                <div class="track-header">
                    <h3 class="track-title">Èü≥ËΩ® ${trackNum}</h3>
                    <div class="track-controls">
                        <div class="file-input-wrapper">
                            <input type="file" id="file${trackNum}" accept="audio/*,video/*,.mp3,.wav,.aac,.m4a,.ogg,.flac,.aiff,.alac,.mp4,.mov,.m4v">
                            <label for="file${trackNum}" class="file-label">üìÅ ÈÄâÊã©Êñá‰ª∂</label>
                        </div>
                        <button class="record-btn" data-track="${trackNum}">üé§ ÂΩïÈü≥</button>
                        <button class="track-play-btn" data-track="${trackNum}">‚ñ∂ Êí≠ÊîæÊú¨ËΩ®</button>
                        <button class="track-download-btn" data-track="${trackNum}" disabled>‚¨áÔ∏è ‰∏ãËΩΩ</button>
                    </div>
                </div>
                <div class="track-info" id="trackInfo${trackNum}">Êú™Âä†ËΩΩ</div>
                <div class="delay-control">
                    <span class="delay-label">Êó∂Èó¥ÂÅèÁßª:</span>
                    <input type="range" class="delay-input" id="delay${trackNum}" min="-10" max="10" step="0.01" value="0">
                    <span class="delay-value" id="delayValue${trackNum}">0.00 Áßí</span>
                </div>
                <div class="waveform-container" id="waveformContainer${trackNum}">
                    <canvas class="waveform-canvas" id="waveform${trackNum}"></canvas>
                    <div class="playback-line" id="playbackLine${trackNum}"></div>
                </div>
            `;
            
            tracksContainer.appendChild(trackDiv);
            
            const fileInput = document.getElementById(`file${trackNum}`);
            const delayInput = document.getElementById(`delay${trackNum}`);
            const delayValue = document.getElementById(`delayValue${trackNum}`);
            const canvas = document.getElementById(`waveform${trackNum}`);
            const container = document.getElementById(`waveformContainer${trackNum}`);
            const playbackLine = document.getElementById(`playbackLine${trackNum}`);
            const trackPlayBtn = document.querySelector(`.track-play-btn[data-track="${trackNum}"]`);
            
            waveformCanvases[index] = canvas;
            playbackLines[index] = playbackLine;
            
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await loadAudio(file, index, trackNum);
                }
            });
            
            delayInput.addEventListener('input', (e) => {
                delays[index] = parseFloat(e.target.value);
                delayValue.textContent = delays[index].toFixed(2) + ' Áßí';
                drawWaveform(index);
            });
            
            container.addEventListener('mousedown', (e) => startDrag(e, index, container));
            container.addEventListener('touchstart', (e) => startDrag(e.touches[0], index, container));
            
            document.addEventListener('mousemove', (e) => onDrag(e, index, container));
            document.addEventListener('touchmove', (e) => onDrag(e.touches[0], index, container));
            
            document.addEventListener('mouseup', () => endDrag(index));
            document.addEventListener('touchend', () => endDrag(index));
            
            const recordBtn = document.querySelector(`[data-track="${trackNum}"]`);
            recordBtn.addEventListener('click', () => toggleRecording(trackNum, index, recordBtn));
            
            trackPlayBtn.addEventListener('click', () => toggleTrackPlay(trackNum, index, trackPlayBtn));
            
            const trackDownloadBtn = document.querySelector(`.track-download-btn[data-track="${trackNum}"]`);
            trackDownloadBtn.addEventListener('click', () => downloadTrack(trackNum, index));
            
            resizeCanvas(canvas);
        }

        function resizeCanvas(canvas) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        window.addEventListener('resize', () => {
            waveformCanvases.forEach((canvas, index) => {
                if (canvas) {
                    resizeCanvas(canvas);
                    if (audioBuffers[index]) {
                        drawWaveform(index);
                    }
                }
            });
        });

        async function loadAudio(file, index, trackNum) {
            try {
                status.textContent = `Ê≠£Âú®Âä†ËΩΩÈü≥ËΩ®${trackNum}...`;
                
                const arrayBuffer = await file.arrayBuffer();
                audioBuffers[index] = await audioContext.decodeAudioData(arrayBuffer);
                
                document.getElementById(`trackInfo${trackNum}`).textContent = 
                    `Â∑≤Âä†ËΩΩ: ${file.name} (${formatTime(audioBuffers[index].duration)})`;
                
                drawWaveform(index);
                updateStatus();
            } catch (error) {
                console.error('Âä†ËΩΩÈü≥È¢ëÂ§±Ë¥•:', error);
                status.textContent = `Âä†ËΩΩÈü≥ËΩ®${trackNum}Â§±Ë¥•`;
            }
        }

        async function downloadTrack(trackNum, index) {
            if (!audioBuffers[index]) return;
            
            try {
                status.textContent = `Ê≠£Âú®ÂáÜÂ§á‰∏ãËΩΩÈü≥ËΩ®${trackNum}...`;
                
                const wavBlob = audioBufferToWav(audioBuffers[index]);
                
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Èü≥ËΩ®${trackNum}_${new Date().getTime()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                status.textContent = `Èü≥ËΩ®${trackNum}‰∏ãËΩΩÊàêÂäü!`;
            } catch (error) {
                console.error('‰∏ãËΩΩÂ§±Ë¥•:', error);
                status.textContent = `Èü≥ËΩ®${trackNum}‰∏ãËΩΩÂ§±Ë¥•`;
            }
        }

        async function downloadMergedAudio() {
            const loadedBuffers = audioBuffers.slice(0, trackCount).filter(b => b !== null);
            if (loadedBuffers.length === 0) return;
            
            try {
                status.textContent = 'Ê≠£Âú®ËûçÂêàÈü≥È¢ë...';
                
                let maxDuration = 0;
                for (let i = 0; i < trackCount; i++) {
                    if (audioBuffers[i]) {
                        const effectiveDelay = delays[i];
                        const trackEndTime = effectiveDelay >= 0 
                            ? audioBuffers[i].duration + effectiveDelay 
                            : audioBuffers[i].duration - Math.abs(effectiveDelay);
                        maxDuration = Math.max(maxDuration, trackEndTime);
                    }
                }
                
                const offlineContext = new OfflineAudioContext(
                    2,
                    Math.ceil(maxDuration * audioContext.sampleRate),
                    audioContext.sampleRate
                );
                
                for (let i = 0; i < trackCount; i++) {
                    if (audioBuffers[i]) {
                        const source = offlineContext.createBufferSource();
                        source.buffer = audioBuffers[i];
                        source.connect(offlineContext.destination);
                        
                        const effectiveDelay = delays[i];
                        
                        if (effectiveDelay >= 0) {
                            source.start(effectiveDelay);
                        } else {
                            const startOffset = Math.abs(effectiveDelay);
                            source.start(0, startOffset);
                        }
                    }
                }
                
                const renderedBuffer = await offlineContext.startRendering();
                
                const wavBlob = audioBufferToWav(renderedBuffer);
                
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ËûçÂêàÈü≥È¢ë_${new Date().getTime()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                status.textContent = 'ËûçÂêàÈü≥È¢ë‰∏ãËΩΩÊàêÂäü!';
            } catch (error) {
                console.error('ËûçÂêàÈü≥È¢ëÂ§±Ë¥•:', error);
                status.textContent = 'ËûçÂêàÈü≥È¢ë‰∏ãËΩΩÂ§±Ë¥•';
            }
        }

        function audioBufferToWav(buffer) {
            const numberOfChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1;
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numberOfChannels * bytesPerSample;
            
            const data = [];
            for (let i = 0; i < numberOfChannels; i++) {
                data.push(buffer.getChannelData(i));
            }
            
            const interleaved = interleave(data);
            const dataLength = interleaved.length * bytesPerSample;
            const headerLength = 44;
            const totalLength = headerLength + dataLength;
            
            const arrayBuffer = new ArrayBuffer(totalLength);
            const view = new DataView(arrayBuffer);
            
            writeString(view, 0, 'RIFF');
            view.setUint32(4, totalLength - 8, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            let offset = 44;
            for (let i = 0; i < interleaved.length; i++) {
                const sample = Math.max(-1, Math.min(1, interleaved[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function interleave(channelData) {
            const length = channelData[0].length;
            const numberOfChannels = channelData.length;
            const result = new Float32Array(length * numberOfChannels);
            
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    result[i * numberOfChannels + channel] = channelData[channel][i];
                }
            }
            
            return result;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function toggleRecording(trackNum, index, btn) {
            if (btn.classList.contains('recording')) {
                mediaRecorders[index].stop();
                btn.textContent = 'üé§ ÂΩïÈü≥';
                btn.classList.remove('recording');
            } else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        } 
                    });
                    
                    mediaRecorders[index] = new MediaRecorder(stream);
                    recordingChunks[index] = [];

                    mediaRecorders[index].ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            recordingChunks[index].push(e.data);
                        }
                    };

                    mediaRecorders[index].onstop = async () => {
                        try {
                            const blob = new Blob(recordingChunks[index], { type: 'audio/webm' });
                            const arrayBuffer = await blob.arrayBuffer();
                            audioBuffers[index] = await audioContext.decodeAudioData(arrayBuffer);
                            
                            document.getElementById(`trackInfo${trackNum}`).textContent = 
                                `Â∑≤Âä†ËΩΩ: ÂΩïÈü≥ (${formatTime(audioBuffers[index].duration)})`;
                            
                            drawWaveform(index);
                            updateStatus();
                        } catch (error) {
                            console.error('Â§ÑÁêÜÂΩïÈü≥Â§±Ë¥•:', error);
                        } finally {
                            stream.getTracks().forEach(track => track.stop());
                        }
                    };

                    mediaRecorders[index].start();
                    btn.textContent = '‚èπ ÂÅúÊ≠¢ÂΩïÈü≥';
                    btn.classList.add('recording');
                    status.textContent = `Ê≠£Âú®ÂΩïÂà∂Èü≥ËΩ®${trackNum}...`;
                } catch (err) {
                    console.error('ÂΩïÈü≥Â§±Ë¥•:', err);
                    status.textContent = 'Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£é';
                }
            }
        }

        function toggleTrackPlay(trackNum, index, btn) {
            if (isTrackPlaying[index]) {
                if (trackSources[index]) {
                    trackSources[index].stop();
                    trackSources[index] = null;
                }
                isTrackPlaying[index] = false;
                btn.textContent = '‚ñ∂ Êí≠ÊîæÊú¨ËΩ®';
                btn.classList.remove('playing');
                playbackLines[index].style.display = 'none';
                cancelAnimationFrame(trackAnimationIds[index]);
                status.textContent = `Èü≥ËΩ®${trackNum}Â∑≤ÂÅúÊ≠¢`;
            } else {
                if (!audioBuffers[index]) {
                    status.textContent = `Èü≥ËΩ®${trackNum}Ê≤°ÊúâÈü≥È¢ëÂÜÖÂÆπ`;
                    return;
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                const offset = trackPauseTimes[index];
                trackStartTimes[index] = audioContext.currentTime - offset;
                
                const effectiveDelay = delays[index];
                const startOffset = Math.max(0, -effectiveDelay);
                const when = Math.max(0, effectiveDelay);
                
                trackSources[index] = audioContext.createBufferSource();
                trackSources[index].buffer = audioBuffers[index];
                trackSources[index].connect(audioContext.destination);
                trackSources[index].start(audioContext.currentTime + when, offset + startOffset);
                
                isTrackPlaying[index] = true;
                btn.textContent = '‚èπ ÂÅúÊ≠¢Êú¨ËΩ®';
                btn.classList.add('playing');
                playbackLines[index].style.display = 'block';
                
                status.textContent = `Ê≠£Âú®Êí≠ÊîæÈü≥ËΩ®${trackNum}...`;
                updateTrackProgress(index, trackNum);
                
                trackSources[index].onended = () => {
                    isTrackPlaying[index] = false;
                    btn.textContent = '‚ñ∂ Êí≠ÊîæÊú¨ËΩ®';
                    btn.classList.remove('playing');
                    playbackLines[index].style.display = 'none';
                    trackPauseTimes[index] = 0;
                    status.textContent = `Èü≥ËΩ®${trackNum}Êí≠ÊîæÂÆåÊØï`;
                };
            }
        }

        function drawWaveform(index) {
            const canvas = waveformCanvases[index];
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const buffer = audioBuffers[index];
            
            if (!buffer) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = '14px Microsoft JhengHei';
                ctx.textAlign = 'center';
                ctx.fillText('Á≠âÂæÖÂä†ËΩΩÈü≥È¢ë...', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const width = canvas.width;
            const height = canvas.height;
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / width);
            const amp = height / 2;
            
            ctx.clearRect(0, 0, width, height);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            const colors = ['#f093fb', '#4facfe', '#43e97b'];
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, colors[index] + 'aa');
            gradient.addColorStop(0.5, colors[index] + 'ff');
            gradient.addColorStop(1, colors[index] + 'aa');
            
            ctx.fillStyle = gradient;
            ctx.strokeStyle = colors[index];
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            
            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;
                
                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }
                
                const yMin = (1 + min) * amp;
                const yMax = (1 + max) * amp;
                
                ctx.lineTo(i, yMax);
            }
            
            for (let i = width - 1; i >= 0; i--) {
                let min = 1.0;
                
                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                }
                
                const yMin = (1 + min) * amp;
                ctx.lineTo(i, yMin);
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            const delay = delays[index];
            if (delay !== 0) {
                const delayX = (delay / buffer.duration) * width;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(Math.abs(delayX), 0);
                ctx.lineTo(Math.abs(delayX), height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Microsoft JhengHei';
                ctx.textAlign = delay > 0 ? 'left' : 'right';
                ctx.fillText(
                    delay > 0 ? 'Âª∂ËøüËµ∑ÁÇπ' : 'ÊèêÂâçËµ∑ÁÇπ',
                    delay > 0 ? Math.abs(delayX) + 5 : Math.abs(delayX) - 5,
                    20
                );
            }
        }

        function startDrag(e, index, container) {
            if (!audioBuffers[index]) return;
            isDragging[index] = true;
            dragStartX[index] = e.clientX || e.pageX;
            dragStartDelay[index] = delays[index];
            container.style.cursor = 'grabbing';
        }

        function onDrag(e, index, container) {
            if (!isDragging[index] || !audioBuffers[index]) return;
            
            const currentX = e.clientX || e.pageX;
            const deltaX = currentX - dragStartX[index];
            const deltaTime = (deltaX / container.offsetWidth) * audioBuffers[index].duration;
            
            delays[index] = Math.max(-10, Math.min(10, dragStartDelay[index] + deltaTime));
            
            document.getElementById(`delay${index + 1}`).value = delays[index];
            document.getElementById(`delayValue${index + 1}`).textContent = 
                delays[index].toFixed(2) + ' Áßí';
            
            drawWaveform(index);
        }

        function endDrag(index) {
            if (isDragging[index]) {
                isDragging[index] = false;
                document.getElementById(`waveformContainer${index + 1}`).style.cursor = 'grab';
            }
        }

        function updateStatus() {
            const loaded = audioBuffers.slice(0, trackCount).filter(b => b !== null).length;
            if (loaded > 0) {
                status.textContent = `‚úì ${loaded}‰∏™Èü≥ËΩ®Â∑≤Â∞±Áª™,ÂèØ‰ª•Êí≠Êîæ`;
                playBtn.disabled = false;
                downloadMergedBtn.disabled = false;
                
                for (let i = 0; i < trackCount; i++) {
                    const downloadBtn = document.querySelector(`.track-download-btn[data-track="${i + 1}"]`);
                    if (downloadBtn) {
                        downloadBtn.disabled = !audioBuffers[i];
                    }
                }
                
                const maxDuration = Math.max(...audioBuffers.slice(0, trackCount).map((b, i) => 
                    b ? b.duration + Math.max(0, delays[i]) : 0
                ));
                durationEl.textContent = formatTime(maxDuration);
            } else {
                status.textContent = 'ËØ∑Âä†ËΩΩÈü≥È¢ëÊñá‰ª∂ÊàñÂΩïÂà∂Èü≥È¢ë';
                playBtn.disabled = true;
                downloadMergedBtn.disabled = true;
                durationEl.textContent = '00:00';
            }
        }

        playBtn.addEventListener('click', () => {
            const loadedBuffers = audioBuffers.slice(0, trackCount).filter(b => b !== null);
            if (loadedBuffers.length === 0) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const offset = pauseTime;
            startTime = audioContext.currentTime - offset;

            for (let i = 0; i < trackCount; i++) {
                if (audioBuffers[i]) {
                    const effectiveDelay = delays[i];
                    const startOffset = Math.max(0, -effectiveDelay);
                    const when = Math.max(0, effectiveDelay);
                    
                    audioSources[i] = audioContext.createBufferSource();
                    audioSources[i].buffer = audioBuffers[i];
                    audioSources[i].connect(audioContext.destination);
                    audioSources[i].start(audioContext.currentTime + when, offset + startOffset);
                    
                    if (playbackLines[i]) {
                        playbackLines[i].style.display = 'block';
                    }
                }
            }

            isPlaying = true;
            status.textContent = `‚ñ∂ Ê≠£Âú®Êí≠Êîæ ${loadedBuffers.length} ‰∏™Èü≥ËΩ®...`;
            updateProgress();
        });

        pauseBtn.addEventListener('click', () => {
            if (!isPlaying) return;

            pauseTime = audioContext.currentTime - startTime;
            
            for (let i = 0; i < trackCount; i++) {
                if (audioSources[i]) {
                    audioSources[i].stop();
                    audioSources[i] = null;
                }
                if (playbackLines[i]) {
                    playbackLines[i].style.display = 'none';
                }
            }

            isPlaying = false;
            status.textContent = '‚è∏ Â∑≤ÊöÇÂÅú';
            cancelAnimationFrame(animationId);
        });

        stopBtn.addEventListener('click', () => {
            for (let i = 0; i < trackCount; i++) {
                if (audioSources[i]) {
                    audioSources[i].stop();
                    audioSources[i] = null;
                }
                if (playbackLines[i]) {
                    playbackLines[i].style.display = 'none';
                }
            }

            isPlaying = false;
            pauseTime = 0;
            startTime = 0;
            currentTimeEl.textContent = '00:00';
            const loadedCount = audioBuffers.slice(0, trackCount).filter(b => b !== null).length;
            status.textContent = `‚èπ Â∑≤ÂÅúÊ≠¢ (${loadedCount}‰∏™Èü≥ËΩ®Â∑≤Âä†ËΩΩ)`;
            cancelAnimationFrame(animationId);
        });

        downloadMergedBtn.addEventListener('click', downloadMergedAudio);

        function updateProgress() {
            if (!isPlaying) return;

            const currentTime = audioContext.currentTime - startTime;
            const loadedBuffers = audioBuffers.slice(0, trackCount).map((b, i) => 
                b ? b.duration + Math.max(0, delays[i]) : 0
            );
            const maxDuration = Math.max(...loadedBuffers);

            currentTimeEl.textContent = formatTime(currentTime);

            for (let i = 0; i < trackCount; i++) {
                if (audioBuffers[i] && playbackLines[i]) {
                    const adjustedTime = currentTime - delays[i];
                    const percent = (adjustedTime / audioBuffers[i].duration) * 100;
                    playbackLines[i].style.left = Math.max(0, Math.min(100, percent)) + '%';
                }
            }

            if (currentTime >= maxDuration) {
                stopBtn.click();
                return;
            }

            animationId = requestAnimationFrame(updateProgress);
        }

        function updateTrackProgress(index, trackNum) {
            if (!isTrackPlaying[index]) return;

            const currentTime = audioContext.currentTime - trackStartTimes[index];
            const bufferDuration = audioBuffers[index].duration;

            if (playbackLines[index]) {
                const adjustedTime = currentTime - delays[index];
                const percent = (adjustedTime / bufferDuration) * 100;
                playbackLines[index].style.left = Math.max(0, Math.min(100, percent)) + '%';
            }

            if (currentTime >= bufferDuration) {
                isTrackPlaying[index] = false;
                document.querySelector(`.track-play-btn[data-track="${trackNum}"]`).textContent = '‚ñ∂ Êí≠ÊîæÊú¨ËΩ®';
                document.querySelector(`.track-play-btn[data-track="${trackNum}"]`).classList.remove('playing');
                playbackLines[index].style.display = 'none';
                trackPauseTimes[index] = 0;
                status.textContent = `Èü≥ËΩ®${trackNum}Êí≠ÊîæÂÆåÊØï`;
                return;
            }

            trackAnimationIds[index] = requestAnimationFrame(() => updateTrackProgress(index, trackNum));
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        playBtn.disabled = true;
    </script>
</body>
</html>