<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜å±±æ—éŸ³å¾‹èåˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'PingFang TC', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px 20px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 100%;
            padding: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .title {
            font-size: 2.5em;
            color: #ffffff;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .tribal-pattern {
            height: 4px;
            background: linear-gradient(90deg, rgba(255,255,255,0.3), rgba(255,255,255,0.8), rgba(255,255,255,0.3));
            margin: 20px auto;
            border-radius: 2px;
            max-width: 600px;
        }

        .config-section {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            margin: 30px auto;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .config-title {
            color: white;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .config-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .config-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1em;
        }

        .track-select {
            padding: 10px 15px;
            border-radius: 10px;
            border: none;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }

        .track-select:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .track-select option {
            background: #764ba2;
            color: white;
        }

        .audio-sources {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin: 40px auto;
            max-width: 1200px;
            padding: 0 20px;
        }

        .audio-input {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            transition: transform 0.3s, box-shadow 0.3s;
            cursor: pointer;
        }

        .audio-input:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .audio-input.loaded {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .audio-input h3 {
            color: white;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-label {
            display: block;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.95em;
        }

        .file-label:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .record-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.95em;
        }

        .record-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .record-btn.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 18px 40px;
            font-size: 1.1em;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            color: white;
        }

        .play-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .pause-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stop-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .spectrum-container {
            margin: 40px auto;
            max-width: 1200px;
            padding: 0 20px;
        }

        .spectrum-canvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: block;
        }

        .progress-container {
            margin: 40px auto;
            max-width: 900px;
            padding: 0 20px;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #fff, rgba(255,255,255,0.7));
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .time-display {
            text-align: center;
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .status {
            text-align: center;
            color: #ffffff;
            font-size: 1.2em;
            margin-top: 30px;
            min-height: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .track-status {
            margin-top: 10px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (max-width: 768px) {
            body {
                padding: 20px 10px;
            }

            .title {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 1em;
            }

            .config-section {
                padding: 15px;
            }

            .config-controls {
                flex-direction: column;
            }

            .audio-sources {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 0 10px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .control-btn {
                width: 100%;
                max-width: 300px;
            }

            .progress-container {
                padding: 0 10px;
            }

            .spectrum-container {
                padding: 0 10px;
            }

            .spectrum-canvas {
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">ğŸµ é«˜å±±æ—éŸ³å¾‹èåˆå™¨</h1>
            <p class="subtitle">èåˆéŸ³å¾‹ Â· éƒ¨è½ä¹‹è²</p>
            <div class="tribal-pattern"></div>
        </div>

        <div class="config-section">
            <h3 class="config-title">å½•åˆ¶è®¾ç½®</h3>
            <div class="config-controls">
                <span class="config-label">é€‰æ‹©å½•åˆ¶éŸ³è½¨æ•°é‡ï¼š</span>
                <select class="track-select" id="trackCount">
                    <option value="1">1ä¸ªéŸ³è½¨</option>
                    <option value="2">2ä¸ªéŸ³è½¨</option>
                    <option value="3" selected>3ä¸ªéŸ³è½¨</option>
                </select>
            </div>
        </div>

        <div class="audio-sources">
            <div class="audio-input" id="input1">
                <h3>éŸ³è½¨ä¸€</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="file1" accept="audio/*,video/*,.mp3,.wav,.aac,.m4a,.ogg,.flac,.aiff,.alac,.mp4,.mov,.m4v">
                    <label for="file1" class="file-label">é€‰æ‹©éŸ³é¢‘</label>
                </div>
                <button class="record-btn" data-track="1">ğŸ¤ å½•éŸ³</button>
                <div class="track-status" id="trackStatus1">æœªåŠ è½½</div>
            </div>

            <div class="audio-input" id="input2">
                <h3>éŸ³è½¨äºŒ</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="file2" accept="audio/*,video/*,.mp3,.wav,.aac,.m4a,.ogg,.flac,.aiff,.alac,.mp4,.mov,.m4v">
                    <label for="file2" class="file-label">é€‰æ‹©éŸ³é¢‘</label>
                </div>
                <button class="record-btn" data-track="2">ğŸ¤ å½•éŸ³</button>
                <div class="track-status" id="trackStatus2">æœªåŠ è½½</div>
            </div>

            <div class="audio-input" id="input3">
                <h3>éŸ³è½¨ä¸‰</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="file3" accept="audio/*,video/*,.mp3,.wav,.aac,.m4a,.ogg,.flac,.aiff,.alac,.mp4,.mov,.m4v">
                    <label for="file3" class="file-label">é€‰æ‹©éŸ³é¢‘</label>
                </div>
                <button class="record-btn" data-track="3">ğŸ¤ å½•éŸ³</button>
                <div class="track-status" id="trackStatus3">æœªåŠ è½½</div>
            </div>
        </div>

        <div class="spectrum-container">
            <canvas id="spectrumCanvas" class="spectrum-canvas"></canvas>
        </div>

        <div class="progress-container">
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="time-display">
                <span id="currentTime">00:00</span> / <span id="duration">00:00</span>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn play-btn" id="playBtn">â–¶ æ’­æ”¾</button>
            <button class="control-btn pause-btn" id="pauseBtn">â¸ æš‚åœ</button>
            <button class="control-btn stop-btn" id="stopBtn">â¹ åœæ­¢</button>
        </div>

        <div class="status" id="status">è¯·åŠ è½½1-3ä¸ªéŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶éŸ³é¢‘</div>
    </div>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffers = [null, null, null];
        let audioSources = [null, null, null];
        let analyser = null;
        let gainNode = null;
        let startTime = 0;
        let pauseTime = 0;
        let isPlaying = false;
        let animationId = null;
        let spectrumAnimationId = null;
        let mediaRecorders = [null, null, null];
        let recordingChunks = [[], [], []];

        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const canvasCtx = spectrumCanvas.getContext('2d');
        const trackCountSelect = document.getElementById('trackCount');

        // è®¾ç½®canvaså°ºå¯¸
        function resizeCanvas() {
            spectrumCanvas.width = spectrumCanvas.offsetWidth;
            spectrumCanvas.height = spectrumCanvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // æ ¹æ®é€‰æ‹©çš„éŸ³è½¨æ•°é‡æ›´æ–°ç•Œé¢
        function updateTrackVisibility() {
            const trackCount = parseInt(trackCountSelect.value);
            
            // æ˜¾ç¤º/éšè—éŸ³è½¨
            for (let i = 1; i <= 3; i++) {
                const trackElement = document.getElementById(`input${i}`);
                if (i <= trackCount) {
                    trackElement.style.display = 'block';
                } else {
                    trackElement.style.display = 'none';
                    
                    // å¦‚æœéŸ³è½¨è¢«éšè—ï¼Œæ¸…é™¤å…¶éŸ³é¢‘ç¼“å†²åŒº
                    if (audioBuffers[i-1]) {
                        audioBuffers[i-1] = null;
                        document.getElementById(`trackStatus${i}`).textContent = 'æœªåŠ è½½';
                    }
                }
            }
            
            // æ›´æ–°çŠ¶æ€
            updateStatus();
        }

        // åˆå§‹åŒ–æ—¶æ›´æ–°éŸ³è½¨å¯è§æ€§
        updateTrackVisibility();
        
        // ç›‘å¬éŸ³è½¨æ•°é‡é€‰æ‹©å˜åŒ–
        trackCountSelect.addEventListener('change', updateTrackVisibility);

        // æ–‡ä»¶åŠ è½½
        for (let i = 1; i <= 3; i++) {
            document.getElementById(`file${i}`).addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        status.textContent = `æ­£åœ¨åŠ è½½éŸ³è½¨${i}...`;
                        
                        // æ£€æŸ¥æ–‡ä»¶ç±»å‹ï¼Œå¦‚æœæ˜¯è§†é¢‘æ–‡ä»¶ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
                        let audioBlob = file;
                        if (file.type.startsWith('video/')) {
                            // å¯¹äºè§†é¢‘æ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•æå–éŸ³é¢‘è½¨é“
                            status.textContent = `æ­£åœ¨ä»è§†é¢‘æ–‡ä»¶ä¸­æå–éŸ³é¢‘...`;
                            audioBlob = await extractAudioFromVideo(file);
                        }
                        
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        audioBuffers[i - 1] = await audioContext.decodeAudioData(arrayBuffer);
                        document.getElementById(`input${i}`).classList.add('loaded');
                        document.getElementById(`trackStatus${i}`).textContent = `å·²åŠ è½½: ${file.name}`;
                        updateStatus();
                    } catch (error) {
                        console.error('åŠ è½½éŸ³é¢‘å¤±è´¥:', error);
                        status.textContent = `åŠ è½½éŸ³è½¨${i}å¤±è´¥: ${error.message}`;
                        
                        // å¦‚æœæ˜¯è§£ç é”™è¯¯ï¼Œå°è¯•ä½¿ç”¨å¤‡é€‰æ–¹æ³•
                        if (error.name === 'EncodingError' || error.name === 'NotSupportedError') {
                            status.textContent = `éŸ³è½¨${i}æ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼`;
                        }
                    }
                }
            });
        }

        // ä»è§†é¢‘æ–‡ä»¶ä¸­æå–éŸ³é¢‘
        async function extractAudioFromVideo(videoFile) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(video);
                const destination = audioContext.createMediaStreamDestination();
                
                source.connect(destination);
                
                video.src = URL.createObjectURL(videoFile);
                video.muted = true; // é™éŸ³ä»¥é¿å…æ’­æ”¾å£°éŸ³
                
                // ä½¿ç”¨MediaRecorderå½•åˆ¶éŸ³é¢‘
                const mediaRecorder = new MediaRecorder(destination.stream);
                const chunks = [];
                
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'audio/wav' });
                    URL.revokeObjectURL(video.src);
                    resolve(blob);
                };
                
                video.onloadedmetadata = () => {
                    mediaRecorder.start();
                    video.play().then(() => {
                        // æ’­æ”¾å®Œæˆååœæ­¢å½•åˆ¶
                        setTimeout(() => {
                            mediaRecorder.stop();
                            source.disconnect();
                        }, video.duration * 1000);
                    }).catch(reject);
                };
                
                video.onerror = reject;
            });
        }

        // å½•éŸ³åŠŸèƒ½
        document.querySelectorAll('.record-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const track = parseInt(btn.dataset.track);
                const index = track - 1;
                
                // æ£€æŸ¥æ˜¯å¦å…è®¸å½•åˆ¶æ­¤éŸ³è½¨
                const trackCount = parseInt(trackCountSelect.value);
                if (track > trackCount) {
                    status.textContent = `å½“å‰è®¾ç½®åªå…è®¸å½•åˆ¶${trackCount}ä¸ªéŸ³è½¨`;
                    return;
                }

                if (btn.classList.contains('recording')) {
                    // åœæ­¢å½•éŸ³
                    mediaRecorders[index].stop();
                    btn.textContent = 'ğŸ¤ å½•éŸ³';
                    btn.classList.remove('recording');
                } else {
                    // å¼€å§‹å½•éŸ³
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                sampleRate: 44100,
                                channelCount: 1
                            } 
                        });
                        mediaRecorders[index] = new MediaRecorder(stream, {
                            mimeType: 'audio/webm;codecs=opus'
                        });
                        recordingChunks[index] = [];

                        mediaRecorders[index].ondataavailable = (e) => {
                            if (e.data.size > 0) {
                                recordingChunks[index].push(e.data);
                            }
                        };

                        mediaRecorders[index].onstop = async () => {
                            try {
                                const blob = new Blob(recordingChunks[index], { type: 'audio/webm' });
                                const arrayBuffer = await blob.arrayBuffer();
                                audioBuffers[index] = await audioContext.decodeAudioData(arrayBuffer);
                                document.getElementById(`input${track}`).classList.add('loaded');
                                document.getElementById(`trackStatus${track}`).textContent = 'å·²åŠ è½½: å½•éŸ³';
                                updateStatus();
                            } catch (error) {
                                console.error('å¤„ç†å½•éŸ³æ•°æ®å¤±è´¥:', error);
                                status.textContent = `å¤„ç†å½•éŸ³æ•°æ®å¤±è´¥: ${error.message}`;
                            } finally {
                                stream.getTracks().forEach(track => track.stop());
                            }
                        };

                        mediaRecorders[index].start();
                        btn.textContent = 'â¹ åœæ­¢å½•éŸ³';
                        btn.classList.add('recording');
                        status.textContent = `æ­£åœ¨å½•åˆ¶éŸ³è½¨${track}...`;
                    } catch (err) {
                        console.error('å½•éŸ³å¤±è´¥:', err);
                        status.textContent = 'æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆå½•éŸ³æƒé™';
                    }
                }
            });
        });

        function updateStatus() {
            const loaded = audioBuffers.filter(b => b !== null).length;
            if (loaded > 0) {
                status.textContent = `âœ“ ${loaded}ä¸ªéŸ³è½¨å·²å°±ç»ªï¼Œå¯ä»¥æ’­æ”¾`;
                playBtn.disabled = false;
                
                // æ›´æ–°æ€»æ—¶é•¿ï¼ˆä½¿ç”¨æœ€é•¿çš„éŸ³é¢‘ï¼‰
                const maxDuration = Math.max(...audioBuffers.map(b => b ? b.duration : 0));
                durationEl.textContent = formatTime(maxDuration);
            } else {
                status.textContent = 'è¯·åŠ è½½1-3ä¸ªéŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶éŸ³é¢‘';
                playBtn.disabled = true;
                durationEl.textContent = '00:00';
            }
            
            // æ›´æ–°é¢‘è°±æ˜¾ç¤º
            if (!isPlaying) {
                drawStaticSpectrum();
            }
        }

        // ç»˜åˆ¶é™æ€é¢‘è°±ï¼ˆæ˜¾ç¤ºå·²åŠ è½½çš„éŸ³é¢‘ï¼‰
        function drawStaticSpectrum() {
            const width = spectrumCanvas.width;
            const height = spectrumCanvas.height;
            
            canvasCtx.clearRect(0, 0, width, height);
            
            const loadedBuffers = audioBuffers.filter(b => b !== null);
            if (loadedBuffers.length === 0) {
                // ç»˜åˆ¶ç©ºçŠ¶æ€
                canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                canvasCtx.fillRect(0, height / 2 - 1, width, 2);
                canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                canvasCtx.font = '14px Microsoft JhengHei';
                canvasCtx.textAlign = 'center';
                canvasCtx.fillText('ç­‰å¾…åŠ è½½éŸ³é¢‘...', width / 2, height / 2 + 20);
                return;
            }
            
            // åˆ†æå·²åŠ è½½éŸ³é¢‘çš„é¢‘ç‡æ•°æ®
            const barCount = 128;
            const barWidth = width / barCount;
            
            // ä¸ºæ¯ä¸ªå·²åŠ è½½çš„éŸ³é¢‘åˆ›å»ºä¸´æ—¶åˆ†æå™¨
            loadedBuffers.forEach((buffer, index) => {
                // ç®€åŒ–çš„é¢‘è°±æ˜¾ç¤º
                for (let i = 0; i < barCount; i++) {
                    const value = Math.random() * 50 + (index + 1) * 30; // æ¨¡æ‹Ÿé¢‘è°±é«˜åº¦
                    const percent = value / 255;
                    const barHeight = height * percent * 0.8;
                    
                    const hue = 280 - (index * 20); // ä¸åŒéŸ³è½¨ä¸åŒé¢œè‰²
                    canvasCtx.fillStyle = `hsla(${hue}, 70%, 60%, 0.3)`;
                    canvasCtx.fillRect(i * barWidth, height - barHeight, barWidth - 2, barHeight);
                }
            });
            
            // å åŠ æ•ˆæœ
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            canvasCtx.font = '12px Microsoft JhengHei';
            canvasCtx.textAlign = 'right';
            canvasCtx.fillText(`${loadedBuffers.length} ä¸ªéŸ³è½¨å·²åŠ è½½`, width - 10, 20);
        }

        // ç»˜åˆ¶åŠ¨æ€é¢‘è°±
        function drawSpectrum() {
            if (!isPlaying) return;
            
            const width = spectrumCanvas.width;
            const height = spectrumCanvas.height;
            const barCount = 128;
            const barWidth = width / barCount;
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            canvasCtx.clearRect(0, 0, width, height);
            
            // åˆ›å»ºå¾‹åŠ¨æ•ˆæœ
            const baseHeight = height * 0.7;
            const amplitude = height * 0.3;
            
            // ç»˜åˆ¶èƒŒæ™¯æ³¢å½¢
            canvasCtx.beginPath();
            canvasCtx.moveTo(0, height / 2);
            
            for (let i = 0; i < barCount; i++) {
                const value = dataArray[i];
                const percent = value / 255;
                const barHeight = baseHeight * percent + amplitude * Math.sin(i * 0.2 + Date.now() * 0.005) * percent;
                
                // ç»˜åˆ¶é¢‘è°±æŸ±
                const hue = 280 - (i % 3) * 20;
                canvasCtx.fillStyle = `hsla(${hue}, 70%, 60%, ${0.4 + percent * 0.6})`;
                canvasCtx.fillRect(i * barWidth, height - barHeight, barWidth - 2, barHeight);
                
                // æ·»åŠ å¾‹åŠ¨ç²’å­æ•ˆæœ
                if (percent > 0.3 && Math.random() > 0.7) {
                    const particleSize = 2 + percent * 4;
                    canvasCtx.fillStyle = `hsla(${hue}, 100%, 80%, ${0.8 * percent})`;
                    canvasCtx.beginPath();
                    canvasCtx.arc(
                        i * barWidth + barWidth/2, 
                        height - barHeight - 5, 
                        particleSize, 
                        0, 
                        Math.PI * 2
                    );
                    canvasCtx.fill();
                }
            }
            
            // ç»˜åˆ¶ä¸­å¿ƒæ³¢å½¢çº¿
            canvasCtx.beginPath();
            canvasCtx.lineWidth = 2;
            
            for (let i = 0; i < barCount; i++) {
                const value = dataArray[i];
                const percent = value / 255;
                const x = i * barWidth + barWidth/2;
                const y = height - (baseHeight * percent + amplitude * Math.sin(i * 0.2 + Date.now() * 0.005) * percent);
                
                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }
            }
            
            const gradient = canvasCtx.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 100, 0.8)');
            gradient.addColorStop(1, 'rgba(100, 100, 255, 0.8)');
            
            canvasCtx.strokeStyle = gradient;
            canvasCtx.stroke();
            
            spectrumAnimationId = requestAnimationFrame(drawSpectrum);
        }

        playBtn.addEventListener('click', () => {
            const loadedBuffers = audioBuffers.filter(b => b !== null);
            if (loadedBuffers.length === 0) return;

            // æ¢å¤AudioContextï¼ˆæŸäº›æµè§ˆå™¨éœ€è¦ï¼‰
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // åˆ›å»ºåˆ†æå™¨å’Œå¢ç›ŠèŠ‚ç‚¹
            if (!analyser) {
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                gainNode = audioContext.createGain();
                gainNode.connect(analyser);
                analyser.connect(audioContext.destination);
            }

            // åˆ›å»ºéŸ³é¢‘æºå¹¶åŒæ—¶æ’­æ”¾ï¼ˆåªæ’­æ”¾å·²åŠ è½½çš„éŸ³è½¨ï¼‰
            const offset = pauseTime;
            startTime = audioContext.currentTime - offset;

            for (let i = 0; i < 3; i++) {
                if (audioBuffers[i]) {
                    audioSources[i] = audioContext.createBufferSource();
                    audioSources[i].buffer = audioBuffers[i];
                    audioSources[i].connect(gainNode);
                    audioSources[i].start(0, offset);
                }
            }

            isPlaying = true;
            status.textContent = `â–¶ æ­£åœ¨æ’­æ”¾ ${loadedBuffers.length} ä¸ªéŸ³è½¨...`;
            updateProgress();
            drawSpectrum();
        });

        pauseBtn.addEventListener('click', () => {
            if (!isPlaying) return;

            pauseTime = audioContext.currentTime - startTime;
            
            for (let i = 0; i < 3; i++) {
                if (audioSources[i]) {
                    audioSources[i].stop();
                    audioSources[i] = null;
                }
            }

            isPlaying = false;
            status.textContent = 'â¸ å·²æš‚åœ';
            cancelAnimationFrame(animationId);
            cancelAnimationFrame(spectrumAnimationId);
            
            // è¿”å›é™æ€é¢‘è°±
            drawStaticSpectrum();
        });

        stopBtn.addEventListener('click', () => {
            for (let i = 0; i < 3; i++) {
                if (audioSources[i]) {
                    audioSources[i].stop();
                    audioSources[i] = null;
                }
            }

            isPlaying = false;
            pauseTime = 0;
            startTime = 0;
            progressFill.style.width = '0%';
            currentTimeEl.textContent = '00:00';
            const loadedCount = audioBuffers.filter(b => b !== null).length;
            status.textContent = `â¹ å·²åœæ­¢ (${loadedCount}ä¸ªéŸ³è½¨å·²åŠ è½½)`;
            cancelAnimationFrame(animationId);
            cancelAnimationFrame(spectrumAnimationId);
            
            // è¿”å›é™æ€é¢‘è°±
            drawStaticSpectrum();
        });

        // è¿›åº¦æ¡ç‚¹å‡»è·³è½¬
        progressBar.addEventListener('click', (e) => {
            const loadedBuffers = audioBuffers.filter(b => b !== null);
            if (loadedBuffers.length === 0) return;

            const rect = progressBar.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const maxDuration = Math.max(...loadedBuffers.map(b => b.duration));
            
            if (isPlaying) {
                // åœæ­¢å½“å‰æ’­æ”¾
                for (let i = 0; i < 3; i++) {
                    if (audioSources[i]) {
                        audioSources[i].stop();
                    }
                }
                
                // ä»æ–°ä½ç½®å¼€å§‹æ’­æ”¾
                pauseTime = percent * maxDuration;
                startTime = audioContext.currentTime - pauseTime;

                for (let i = 0; i < 3; i++) {
                    if (audioBuffers[i]) {
                        audioSources[i] = audioContext.createBufferSource();
                        audioSources[i].buffer = audioBuffers[i];
                        audioSources[i].connect(gainNode);
                        audioSources[i].start(0, pauseTime);
                    }
                }
            } else {
                pauseTime = percent * maxDuration;
                progressFill.style.width = (percent * 100) + '%';
                currentTimeEl.textContent = formatTime(pauseTime);
            }
        });

        function updateProgress() {
            if (!isPlaying) return;

            const currentTime = audioContext.currentTime - startTime;
            const loadedBuffers = audioBuffers.filter(b => b !== null);
            const maxDuration = Math.max(...loadedBuffers.map(b => b.duration));
            const percent = (currentTime / maxDuration) * 100;

            progressFill.style.width = Math.min(percent, 100) + '%';
            currentTimeEl.textContent = formatTime(currentTime);

            if (currentTime >= maxDuration) {
                stopBtn.click();
                return;
            }

            animationId = requestAnimationFrame(updateProgress);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // åˆå§‹åŒ–çŠ¶æ€
        playBtn.disabled = true;
        
        // åˆå§‹ç»˜åˆ¶é™æ€é¢‘è°±
        drawStaticSpectrum();
    </script>
</body>
</html>