<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜å±±æ—éŸ³å¾‹èåˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'PingFang TC', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .title {
            font-size: 2.5em;
            color: #ffffff;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .tribal-pattern {
            height: 4px;
            background: linear-gradient(90deg, rgba(255,255,255,0.3), rgba(255,255,255,0.8), rgba(255,255,255,0.3));
            margin: 20px auto;
            border-radius: 2px;
            max-width: 600px;
        }

        .track-control-section {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            margin: 30px auto;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .track-control-title {
            color: white;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .track-count-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .track-count-btn {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.95em;
        }

        .track-count-btn.active {
            background: rgba(255, 255, 255, 0.7);
            color: #764ba2;
            font-weight: bold;
        }

        .track-count-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .track-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .track-title {
            color: white;
            font-size: 1.3em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .track-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-label {
            display: inline-block;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
        }

        .file-label:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .record-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
        }

        .record-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .record-btn.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .delay-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .delay-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95em;
            min-width: 80px;
        }

        .delay-input {
            flex: 1;
            max-width: 300px;
        }

        .delay-value {
            color: white;
            font-weight: bold;
            min-width: 80px;
            text-align: right;
            font-size: 0.95em;
        }

        .waveform-container {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            cursor: grab;
            margin-top: 10px;
            height: 120px;
        }

        .waveform-container:active {
            cursor: grabbing;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .playback-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            display: none;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 18px 40px;
            font-size: 1.1em;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            color: white;
        }

        .play-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .pause-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stop-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .time-display {
            text-align: center;
            margin: 20px 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        .status {
            text-align: center;
            color: #ffffff;
            font-size: 1.2em;
            margin-top: 30px;
            min-height: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .track-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
            margin-top: 10px;
            text-align: center;
        }

        @media (max-width: 768px) {
            body {
                padding: 20px 10px;
            }

            .title {
                font-size: 1.8em;
            }

            .track-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .track-controls {
                width: 100%;
                justify-content: center;
            }

            .delay-control {
                flex-direction: column;
                align-items: stretch;
            }

            .delay-value {
                text-align: center;
            }

            .control-btn {
                width: 100%;
                max-width: 300px;
            }

            .waveform-container {
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">ğŸµ é«˜å±±æ—éŸ³å¾‹èåˆå™¨</h1>
            <p class="subtitle">ç²¾å‡†å¯¹é½ Â· å®Œç¾èåˆ</p>
            <div class="tribal-pattern"></div>
        </div>

        <div class="track-control-section">
            <div class="track-control-title">ğŸ›ï¸ é€‰æ‹©éŸ³è½¨æ•°é‡</div>
            <div class="track-count-selector">
                <button class="track-count-btn active" data-count="1">1 ä¸ªéŸ³è½¨</button>
                <button class="track-count-btn" data-count="2">2 ä¸ªéŸ³è½¨</button>
                <button class="track-count-btn" data-count="3">3 ä¸ªéŸ³è½¨</button>
            </div>
        </div>

        <div id="tracksContainer"></div>

        <div class="time-display">
            <span id="currentTime">00:00</span> / <span id="duration">00:00</span>
        </div>

        <div class="controls">
            <button class="control-btn play-btn" id="playBtn">â–¶ æ’­æ”¾</button>
            <button class="control-btn pause-btn" id="pauseBtn">â¸ æš‚åœ</button>
            <button class="control-btn stop-btn" id="stopBtn">â¹ åœæ­¢</button>
        </div>

        <div class="status" id="status">è¯·åŠ è½½éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶éŸ³é¢‘</div>
    </div>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffers = [null, null, null];
        let audioSources = [null, null, null];
        let delays = [0, 0, 0]; // å»¶è¿Ÿå€¼ï¼ˆç§’ï¼‰
        let startTime = 0;
        let pauseTime = 0;
        let isPlaying = false;
        let animationId = null;
        let mediaRecorders = [null, null, null];
        let recordingChunks = [[], [], []];
        let waveformCanvases = [];
        let playbackLines = [];
        let isDragging = [false, false, false];
        let dragStartX = [0, 0, 0];
        let dragStartDelay = [0, 0, 0];
        let trackCount = 1;

        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const tracksContainer = document.getElementById('tracksContainer');

        // åˆ›å»ºåˆå§‹éŸ³è½¨
        createTracks(trackCount);

        // éŸ³è½¨æ•°é‡é€‰æ‹©äº‹ä»¶
        document.querySelectorAll('.track-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.track-count-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                trackCount = parseInt(btn.dataset.count);
                createTracks(trackCount);
            });
        });

        function createTracks(count) {
            // åœæ­¢æ‰€æœ‰æ’­æ”¾
            stopBtn.click();
            
            // æ¸…ç©ºå®¹å™¨
            tracksContainer.innerHTML = '';
            audioBuffers = [null, null, null];
            delays = [0, 0, 0];
            waveformCanvases = [];
            playbackLines = [];
            
            // åˆ›å»ºæŒ‡å®šæ•°é‡çš„éŸ³è½¨
            for (let i = 1; i <= count; i++) {
                createTrack(i);
            }
            
            updateStatus();
        }

        function createTrack(trackNum) {
            const index = trackNum - 1;
            const colors = ['#f093fb', '#4facfe', '#43e97b'];
            
            const trackDiv = document.createElement('div');
            trackDiv.className = 'track-container';
            trackDiv.id = `track${trackNum}`;
            trackDiv.style.background = `linear-gradient(135deg, ${colors[index]}22, ${colors[index]}11)`;
            
            trackDiv.innerHTML = `
                <div class="track-header">
                    <h3 class="track-title">éŸ³è½¨ ${trackNum}</h3>
                    <div class="track-controls">
                        <div class="file-input-wrapper">
                            <input type="file" id="file${trackNum}" accept="audio/*,video/*,.mp3,.wav,.aac,.m4a,.ogg,.flac,.aiff,.alac,.mp4,.mov,.m4v">
                            <label for="file${trackNum}" class="file-label">ğŸ“ é€‰æ‹©æ–‡ä»¶</label>
                        </div>
                        <button class="record-btn" data-track="${trackNum}">ğŸ¤ å½•éŸ³</button>
                    </div>
                </div>
                <div class="track-info" id="trackInfo${trackNum}">æœªåŠ è½½</div>
                <div class="delay-control">
                    <span class="delay-label">æ—¶é—´åç§»ï¼š</span>
                    <input type="range" class="delay-input" id="delay${trackNum}" min="-10" max="10" step="0.01" value="0">
                    <span class="delay-value" id="delayValue${trackNum}">0.00 ç§’</span>
                </div>
                <div class="waveform-container" id="waveformContainer${trackNum}">
                    <canvas class="waveform-canvas" id="waveform${trackNum}"></canvas>
                    <div class="playback-line" id="playbackLine${trackNum}"></div>
                </div>
            `;
            
            tracksContainer.appendChild(trackDiv);
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬
            const fileInput = document.getElementById(`file${trackNum}`);
            const delayInput = document.getElementById(`delay${trackNum}`);
            const delayValue = document.getElementById(`delayValue${trackNum}`);
            const canvas = document.getElementById(`waveform${trackNum}`);
            const container = document.getElementById(`waveformContainer${trackNum}`);
            const playbackLine = document.getElementById(`playbackLine${trackNum}`);
            
            waveformCanvases[index] = canvas;
            playbackLines[index] = playbackLine;
            
            // æ–‡ä»¶åŠ è½½
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await loadAudio(file, index, trackNum);
                }
            });
            
            // å»¶è¿Ÿæ§åˆ¶
            delayInput.addEventListener('input', (e) => {
                delays[index] = parseFloat(e.target.value);
                delayValue.textContent = delays[index].toFixed(2) + ' ç§’';
                drawWaveform(index);
            });
            
            // æ³¢å½¢æ‹–åŠ¨
            container.addEventListener('mousedown', (e) => startDrag(e, index, container));
            container.addEventListener('touchstart', (e) => startDrag(e.touches[0], index, container));
            
            document.addEventListener('mousemove', (e) => onDrag(e, index, container));
            document.addEventListener('touchmove', (e) => onDrag(e.touches[0], index, container));
            
            document.addEventListener('mouseup', () => endDrag(index));
            document.addEventListener('touchend', () => endDrag(index));
            
            // å½•éŸ³æŒ‰é’®
            const recordBtn = document.querySelector(`[data-track="${trackNum}"]`);
            recordBtn.addEventListener('click', () => toggleRecording(trackNum, index, recordBtn));
            
            // åˆå§‹åŒ–canvaså°ºå¯¸
            resizeCanvas(canvas);
        }

        function resizeCanvas(canvas) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        window.addEventListener('resize', () => {
            waveformCanvases.forEach((canvas, index) => {
                if (canvas) {
                    resizeCanvas(canvas);
                    if (audioBuffers[index]) {
                        drawWaveform(index);
                    }
                }
            });
        });

        async function loadAudio(file, index, trackNum) {
            try {
                status.textContent = `æ­£åœ¨åŠ è½½éŸ³è½¨${trackNum}...`;
                
                const arrayBuffer = await file.arrayBuffer();
                audioBuffers[index] = await audioContext.decodeAudioData(arrayBuffer);
                
                document.getElementById(`trackInfo${trackNum}`).textContent = 
                    `å·²åŠ è½½: ${file.name} (${formatTime(audioBuffers[index].duration)})`;
                
                drawWaveform(index);
                updateStatus();
            } catch (error) {
                console.error('åŠ è½½éŸ³é¢‘å¤±è´¥:', error);
                status.textContent = `åŠ è½½éŸ³è½¨${trackNum}å¤±è´¥`;
            }
        }

        async function toggleRecording(trackNum, index, btn) {
            if (btn.classList.contains('recording')) {
                mediaRecorders[index].stop();
                btn.textContent = 'ğŸ¤ å½•éŸ³';
                btn.classList.remove('recording');
            } else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        } 
                    });
                    
                    mediaRecorders[index] = new MediaRecorder(stream);
                    recordingChunks[index] = [];

                    mediaRecorders[index].ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            recordingChunks[index].push(e.data);
                        }
                    };

                    mediaRecorders[index].onstop = async () => {
                        try {
                            const blob = new Blob(recordingChunks[index], { type: 'audio/webm' });
                            const arrayBuffer = await blob.arrayBuffer();
                            audioBuffers[index] = await audioContext.decodeAudioData(arrayBuffer);
                            
                            document.getElementById(`trackInfo${trackNum}`).textContent = 
                                `å·²åŠ è½½: å½•éŸ³ (${formatTime(audioBuffers[index].duration)})`;
                            
                            drawWaveform(index);
                            updateStatus();
                        } catch (error) {
                            console.error('å¤„ç†å½•éŸ³å¤±è´¥:', error);
                        } finally {
                            stream.getTracks().forEach(track => track.stop());
                        }
                    };

                    mediaRecorders[index].start();
                    btn.textContent = 'â¹ åœæ­¢å½•éŸ³';
                    btn.classList.add('recording');
                    status.textContent = `æ­£åœ¨å½•åˆ¶éŸ³è½¨${trackNum}...`;
                } catch (err) {
                    console.error('å½•éŸ³å¤±è´¥:', err);
                    status.textContent = 'æ— æ³•è®¿é—®éº¦å…‹é£';
                }
            }
        }

        function drawWaveform(index) {
            const canvas = waveformCanvases[index];
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const buffer = audioBuffers[index];
            
            if (!buffer) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = '14px Microsoft JhengHei';
                ctx.textAlign = 'center';
                ctx.fillText('ç­‰å¾…åŠ è½½éŸ³é¢‘...', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const width = canvas.width;
            const height = canvas.height;
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / width);
            const amp = height / 2;
            
            ctx.clearRect(0, 0, width, height);
            
            // ç»˜åˆ¶ä¸­çº¿
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            // ç»˜åˆ¶æ³¢å½¢
            const colors = ['#f093fb', '#4facfe', '#43e97b'];
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, colors[index] + 'aa');
            gradient.addColorStop(0.5, colors[index] + 'ff');
            gradient.addColorStop(1, colors[index] + 'aa');
            
            ctx.fillStyle = gradient;
            ctx.strokeStyle = colors[index];
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            
            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;
                
                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }
                
                const yMin = (1 + min) * amp;
                const yMax = (1 + max) * amp;
                
                ctx.lineTo(i, yMax);
            }
            
            for (let i = width - 1; i >= 0; i--) {
                let min = 1.0;
                
                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                }
                
                const yMin = (1 + min) * amp;
                ctx.lineTo(i, yMin);
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // æ˜¾ç¤ºå»¶è¿Ÿæ ‡è®°
            const delay = delays[index];
            if (delay !== 0) {
                const delayX = (delay / buffer.duration) * width;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(Math.abs(delayX), 0);
                ctx.lineTo(Math.abs(delayX), height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Microsoft JhengHei';
                ctx.textAlign = delay > 0 ? 'left' : 'right';
                ctx.fillText(
                    delay > 0 ? 'å»¶è¿Ÿèµ·ç‚¹' : 'æå‰èµ·ç‚¹',
                    delay > 0 ? Math.abs(delayX) + 5 : Math.abs(delayX) - 5,
                    20
                );
            }
        }

        function startDrag(e, index, container) {
            if (!audioBuffers[index]) return;
            isDragging[index] = true;
            dragStartX[index] = e.clientX || e.pageX;
            dragStartDelay[index] = delays[index];
            container.style.cursor = 'grabbing';
        }

        function onDrag(e, index, container) {
            if (!isDragging[index] || !audioBuffers[index]) return;
            
            const currentX = e.clientX || e.pageX;
            const deltaX = currentX - dragStartX[index];
            const deltaTime = (deltaX / container.offsetWidth) * audioBuffers[index].duration;
            
            delays[index] = Math.max(-10, Math.min(10, dragStartDelay[index] + deltaTime));
            
            // æ›´æ–°å¯¹åº”çš„æ»‘å—å’Œæ˜¾ç¤ºå€¼
            document.getElementById(`delay${index + 1}`).value = delays[index];
            document.getElementById(`delayValue${index + 1}`).textContent = 
                delays[index].toFixed(2) + ' ç§’';
            
            drawWaveform(index);
        }

        function endDrag(index) {
            if (isDragging[index]) {
                isDragging[index] = false;
                document.getElementById(`waveformContainer${index + 1}`).style.cursor = 'grab';
            }
        }

        function updateStatus() {
            const loaded = audioBuffers.slice(0, trackCount).filter(b => b !== null).length;
            if (loaded > 0) {
                status.textContent = `âœ“ ${loaded}ä¸ªéŸ³è½¨å·²å°±ç»ªï¼Œå¯ä»¥æ’­æ”¾`;
                playBtn.disabled = false;
                
                const maxDuration = Math.max(...audioBuffers.slice(0, trackCount).map((b, i) => 
                    b ? b.duration + Math.max(0, delays[i]) : 0
                ));
                durationEl.textContent = formatTime(maxDuration);
            } else {
                status.textContent = 'è¯·åŠ è½½éŸ³é¢‘æ–‡ä»¶æˆ–å½•åˆ¶éŸ³é¢‘';
                playBtn.disabled = true;
                durationEl.textContent = '00:00';
            }
        }

        playBtn.addEventListener('click', () => {
            const loadedBuffers = audioBuffers.slice(0, trackCount).filter(b => b !== null);
            if (loadedBuffers.length === 0) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const offset = pauseTime;
            startTime = audioContext.currentTime - offset;

            for (let i = 0; i < trackCount; i++) {
                if (audioBuffers[i]) {
                    const effectiveDelay = delays[i];
                    const startOffset = Math.max(0, -effectiveDelay);
                    const when = Math.max(0, effectiveDelay);
                    
                    audioSources[i] = audioContext.createBufferSource();
                    audioSources[i].buffer = audioBuffers[i];
                    audioSources[i].connect(audioContext.destination);
                    audioSources[i].start(audioContext.currentTime + when, offset + startOffset);
                    
                    if (playbackLines[i]) {
                        playbackLines[i].style.display = 'block';
                    }
                }
            }

            isPlaying = true;
            status.textContent = `â–¶ æ­£åœ¨æ’­æ”¾ ${loadedBuffers.length} ä¸ªéŸ³è½¨...`;
            updateProgress();
        });

        pauseBtn.addEventListener('click', () => {
            if (!isPlaying) return;

            pauseTime = audioContext.currentTime - startTime;
            
            for (let i = 0; i < trackCount; i++) {
                if (audioSources[i]) {
                    audioSources[i].stop();
                    audioSources[i] = null;
                }
                if (playbackLines[i]) {
                    playbackLines[i].style.display = 'none';
                }
            }

            isPlaying = false;
            status.textContent = 'â¸ å·²æš‚åœ';
            cancelAnimationFrame(animationId);
        });

        stopBtn.addEventListener('click', () => {
            for (let i = 0; i < trackCount; i++) {
                if (audioSources[i]) {
                    audioSources[i].stop();
                    audioSources[i] = null;
                }
                if (playbackLines[i]) {
                    playbackLines[i].style.display = 'none';
                }
            }

            isPlaying = false;
            pauseTime = 0;
            startTime = 0;
            currentTimeEl.textContent = '00:00';
            const loadedCount = audioBuffers.slice(0, trackCount).filter(b => b !== null).length;
            status.textContent = `â¹ å·²åœæ­¢ (${loadedCount}ä¸ªéŸ³è½¨å·²åŠ è½½)`;
            cancelAnimationFrame(animationId);
        });

        function updateProgress() {
            if (!isPlaying) return;

            const currentTime = audioContext.currentTime - startTime;
            const loadedBuffers = audioBuffers.slice(0, trackCount).map((b, i) => 
                b ? b.duration + Math.max(0, delays[i]) : 0
            );
            const maxDuration = Math.max(...loadedBuffers);

            currentTimeEl.textContent = formatTime(currentTime);

            // æ›´æ–°æ’­æ”¾çº¿ä½ç½®
            for (let i = 0; i < trackCount; i++) {
                if (audioBuffers[i] && playbackLines[i]) {
                    const adjustedTime = currentTime - delays[i];
                    const percent = (adjustedTime / audioBuffers[i].duration) * 100;
                    playbackLines[i].style.left = Math.max(0, Math.min(100, percent)) + '%';
                }
            }

            if (currentTime >= maxDuration) {
                stopBtn.click();
                return;
            }

            animationId = requestAnimationFrame(updateProgress);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // åˆå§‹åŒ–çŠ¶æ€
        playBtn.disabled = true;
    </script>
</body>
</html>